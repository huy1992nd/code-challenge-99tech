## Problem 5: A Crude Server (Express + TypeScript + Prisma)

This service exposes CRUD endpoints for a `Resource` entity and persists data via Prisma.

### Stack
- ExpressJS
- TypeScript
- Prisma (PostgreSQL by default)

### Prerequisites
- Node.js 18+
- PostgreSQL (or adjust `provider` and `DATABASE_URL` for another supported DB)

### Setup
1) Install deps
```bash
cd src/problem5
npm install
```

2) Configure env
Create `.env` in this folder with:
```bash
DATABASE_URL="postgresql://user:password@localhost:5432/mydb?schema=public"
```

3) Generate client and run migrations
```bash
npm run prisma:generate
npm run prisma:migrate
```

### Development
```bash
npm run dev
```
Server: http://localhost:3000

OpenAPI spec is auto-generated by TSOA at `src/problem5/src/generated/swagger.json`.
Regenerate after controller changes:
```bash
npm run tsoa:gen
```

### Build + Start
```bash
npm run build
npm start
```

### Docker
Build image:
```bash
docker build -t problem5-api:latest .
```

Run (requires DATABASE_URL):
```bash
docker run -p 3000:3000 \
  -e DATABASE_URL="postgresql://postgres:postgres@host.docker.internal:5432/mydb?schema=public" \
  --name problem5-api problem5-api:latest
```

With docker compose (Postgres + API):
```bash
docker compose up -d
# set DATABASE_URL in .env to use localhost:5432
```

### Deploying on AWS (example)
You can use any container runtime. Two common approaches:

1) AWS Elastic Beanstalk (single container)
- Create ECR repo and push image `problem5-api:latest`.
- In EB console, create new app (Platform: Docker). Provide image via ECR URL.
- Set environment variables: `PORT=3000`, `DATABASE_URL=...`.
- Configure health check path `/health`.

2) AWS ECS on Fargate
- Build & push image to ECR:
  ```bash
  aws ecr create-repository --repository-name problem5-api
  # login, tag and push
  ```
- Create Task Definition:
  - Container port: 3000
  - Env: `DATABASE_URL`, optional `PORT`
- Create ECS Service in a cluster (Fargate), attach an ALB:
  - Target group health check: `/health`
  - Listener: 80/443 -> target group
- Networking: place service in private subnets, ALB in public; add NAT if needed.

Database options on AWS:
- Amazon RDS for PostgreSQL. Set security groups to allow from ECS tasks.
- Or use Aurora PostgreSQL-compatible.

Migrations in production:
- Prefer running `prisma migrate deploy` as a one-off task or in CI/CD before updating service.
- You can also bake it into an init container or a preStart hook in your pipeline.

### Endpoints
- POST `/resources` { name: string, description?: string }
- GET `/resources?name=foo&skip=0&take=20`
- GET `/resources/:id`
- PUT `/resources/:id` { name?: string, description?: string }
- DELETE `/resources/:id`
